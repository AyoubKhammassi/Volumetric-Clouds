// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

Texture2D<float4> spriteSheet;
SamplerState sampler_spriteSheet;
//Number of frames in X and Y components, sprite sheet resolution in Z and W
float4 data;
float depth;
float depthStep;
RWTexture3D<float4> result;

//Index Conversion functions
//converts an int index to a two dimensional index
uint2 OneDtoTwoDIndex(uint2 XYFrames, uint index)
{
	uint y = index / XYFrames.x;
	uint x = index % XYFrames.x;
	return uint2(x, y);
}

//converts an int2 index to one dimensional index
uint TwoDto1DIndex(uint2 XYFrames, uint2 index)
{
	return dot(index, XYFrames);
}
float2 uvw2uv(float3 uvw)
{
	uint nSprites =(uint)data.x * (uint)data.y;
	//float zStep = 1 / (nSprites);

	uint zSprites = (uint)(uvw.z * nSprites);
	//X and Y are the origin 
	uint y = zSprites / (uint)(data.x);
	uint x = zSprites % (uint)(data.x);

	//normalized UVs
	float2 nUVs = uvw.xy / (data.xy);
	return ((float2(x, y) / (data.xy)) + nUVs);
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 res = float3(data.zw / data.xy, depth);
	float3 uvw = id.xyz / res;//this can be used to sample the sprite sheet

	float2 uv = uvw2uv(uvw);
	float2 nUVs = uvw.xy / data.xy;

	//the sprite sheet origin is on the top left, so we need to convert the UVs to that space
	uv.y = abs(uv.y - 1.0);
	result[id] = spriteSheet.SampleLevel(sampler_spriteSheet, uv, 0);
}
