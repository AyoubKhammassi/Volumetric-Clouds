// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Textures
Texture2D<float4> spriteSheet;
RWTexture3D<float4> result;
//Sampler states
SamplerState sampler_spriteSheet;

//Metadata vars
//Number of frames in X and Y components, sprite sheet resolution in Z and W
float4 data;
float depth;
float depthStep;
uint numberOfSprites;

//Converts a 3 dimensional normalized indices uvw to 2 dimensional uv
float2 uvw2uv(float3 uvw)
{
	uint numberOfSprites =(uint)data.x * (uint)data.y;
	//float zStep = 1 / (numberOfSprites);

	uint zSprites = (uint)(uvw.z * numberOfSprites);
	//X and Y are the origin 
	uint y = zSprites / (uint)(data.x);
	uint x = zSprites % (uint)(data.x);

	//normalized UVs
	float2 nUVs = uvw.xy / (data.xy);
	return ((float2(x, y) / (data.xy)) + nUVs);
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 res = float3(data.zw / data.xy, depth);
	float3 uvw = id.xyz / res;//this can be used to sample the sprite sheet

	float2 uv = uvw2uv(uvw);
	float2 nUVs = uvw.xy / data.xy;

	//the sprite sheet origin is on the top left, so we need to convert the UVs to that space
	uv.y = abs(uv.y - 1.0);
	result[id] = spriteSheet.SampleLevel(sampler_spriteSheet, uv, 0).w;
}
